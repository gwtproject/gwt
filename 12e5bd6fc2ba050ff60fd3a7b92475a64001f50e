{
  "comments": [
    {
      "key": {
        "uuid": "7c58ad41_e30d0954",
        "filename": "dev/core/super/com/google/gwt/dev/jjs/intrinsic/com/google/gwt/lang/Cast.java",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 5001
      },
      "writtenOn": "2014-03-01T01:54:50Z",
      "side": 1,
      "message": "This entry will not exist if the class isn\u0027t instantiated.\nFor example, \n\nclass A{}\nclass B{} extends A\n\nB.class.isAssignableFrom(A.class);\n\nThe GWT compiler will completely prune A and B as they are never instantiated. Therefore, they will get no type ids. Therefore, you won\u0027t be able to look up the prototypes.\n\nOk, let\u0027s allocate them:\nnew B()\nnew A()\n\nand let\u0027s make A implements X, Y, Z\n\nNow, will A.class.isAssignableFrom(X.class) work?\n\nNo, it will not. Because CastNormalizer only synthesizes CastMap entries for types that are actually recorded as the target of an \u0027instanceof\u0027 operation. \n\nIn order to make this work, you\u0027d have to put in a special compiler pass to recognize the argument of isAssignableFrom() and ensure that it is added to the CastMap. However, this will fail if things aren\u0027t done with literal classes, e.g\n\nList\u003cClass\u003e classes \u003d Arrays.asList(X.class, Y.class, Z.class);\n\nfor (Class x : classes) A.class.isAssignableFrom(x); // ooops, we don\u0027t know what X is\n\n\nThis is why supporting this method has always been very low on our list, because doing it actually requires lugging around type information for every type that is referenced, and therefore, the CastMaps of all used classes will get bigger.\n\nThis might be fixable when we switch to using a deliberate field flag system for runtime information, e.g. we represent A as\n\nA.prototype.__implements_X\u003dtrue\nA.prototype.__implements_Y\u003dtrue\nA.prototype.__implements_Z\u003dtrue\n\nNow \u0027instanceof X\u0027 is translated as \u0027o.__implements_X\u0027\n\nAnd Class.isAssignableFrom would be represented as a dictionary lookup of the right __implements_Blah, and we could teach Js Optimizer to prune all unreferenced fields, either by direct property access or by \u0027quoted\u0027 dictionary lookup. Still, it will result in some code bloat.\n\nIn general, generating \u0027instanceof\u0027 helper methods is superior.",
      "revId": "12e5bd6fc2ba050ff60fd3a7b92475a64001f50e",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c58ad41_e3f62900",
        "filename": "dev/core/super/com/google/gwt/dev/jjs/intrinsic/com/google/gwt/lang/Cast.java",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 5105
      },
      "writtenOn": "2014-03-01T02:05:48Z",
      "side": 1,
      "message": "I guess this will never be called with String as srcTypeId right! other wise should be rewriten as\n\nvar prototype \u003d ...\n\nreturn canCast(prototype, dstTypeId)\n\n\nwhich is a bit cleaner than almost duplicating the test.\n\nI think I am fed up with the extremely long fully qualified JSNI refs, I will do smthng about it.",
      "revId": "12e5bd6fc2ba050ff60fd3a7b92475a64001f50e",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c58ad41_43205580",
        "filename": "dev/core/super/com/google/gwt/dev/jjs/intrinsic/com/google/gwt/lang/Cast.java",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 5110
      },
      "writtenOn": "2014-03-01T02:12:23Z",
      "side": 1,
      "message": "That\u0027s the spirit :)\n\nWe should force compiler guys write even more GWT code for such improvements.",
      "parentUuid": "7c58ad41_e3f62900",
      "revId": "12e5bd6fc2ba050ff60fd3a7b92475a64001f50e",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c58ad41_f9b938aa",
        "filename": "dev/core/super/com/google/gwt/dev/jjs/intrinsic/com/google/gwt/lang/Cast.java",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 5105
      },
      "writtenOn": "2014-03-02T22:36:38Z",
      "side": 1,
      "message": "For now this is a clutch to implement runtime rebind rules in separate compilation (used by dev.cfg.ConditionWhenTypeAssignableTo); in separate compilation (which as of now is only unoptimized) nothing is pruned and for every defined class a full cast map is computed and is registered in the prototypesById map. With the exception of Arrays, primitives and String, which are not registered in prototypedById and.\n\nA different option would have been instead of evaluating all rebind rules at runtime in separate compilation use a scheme similar to soft permutations; but that scheme requires global information hence it can not be done piecewise modularly but it could be done at link time. We might need to iterate after modular compilation is a reality (pretty soon).",
      "parentUuid": "7c58ad41_e30d0954",
      "revId": "12e5bd6fc2ba050ff60fd3a7b92475a64001f50e",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dc76f9c4_73a1c08d",
        "filename": "dev/core/super/com/google/gwt/dev/jjs/intrinsic/com/google/gwt/lang/Cast.java",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 5410
      },
      "writtenOn": "2014-03-04T19:27:00Z",
      "side": 1,
      "message": "added comments making it clear that, yes, these functions are only correct when supporting type information is available. also added comments mentioning that direct dynamic usage of \"canCastTypeId\" is only done during library compilation",
      "parentUuid": "7c58ad41_f9b938aa",
      "revId": "12e5bd6fc2ba050ff60fd3a7b92475a64001f50e",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c58ad41_08939cff",
        "filename": "dev/core/test/com/google/gwt/dev/cfg/ConditionTest.java",
        "patchSetId": 1
      },
      "lineNbr": 125,
      "author": {
        "id": 5110
      },
      "writtenOn": "2014-03-01T01:30:06Z",
      "side": 1,
      "message": "Hey there :)",
      "revId": "12e5bd6fc2ba050ff60fd3a7b92475a64001f50e",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c58ad41_4eff55d1",
        "filename": "dev/core/test/com/google/gwt/dev/cfg/ConditionTest.java",
        "patchSetId": 1
      },
      "lineNbr": 125,
      "author": {
        "id": 5410
      },
      "writtenOn": "2014-03-04T19:27:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7c58ad41_08939cff",
      "revId": "12e5bd6fc2ba050ff60fd3a7b92475a64001f50e",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c58ad41_e8f16849",
        "filename": "user/super/com/google/gwt/emul/java/lang/Class.java",
        "patchSetId": 1
      },
      "lineNbr": 287,
      "author": {
        "id": 5110
      },
      "writtenOn": "2014-03-01T01:30:06Z",
      "side": 1,
      "message": "I thought this was avoided for long time because of the potential code bloat?\n\nAlso see https://code.google.com/p/google-web-toolkit/issues/detail?id\u003d4663",
      "revId": "12e5bd6fc2ba050ff60fd3a7b92475a64001f50e",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c58ad41_83d40d32",
        "filename": "user/super/com/google/gwt/emul/java/lang/Class.java",
        "patchSetId": 1
      },
      "lineNbr": 287,
      "author": {
        "id": 5105
      },
      "writtenOn": "2014-03-01T02:05:48Z",
      "side": 1,
      "message": "I see what you mean, in separate compilation draft mode we have a full representation of the hierarchy and this would work correctly without more overhead.\n\nAs it is done in this patch it would not really work in optimized mode, it would only consider assignability from the persepective of seen asignability (if the compiler has to do a check then the information would be there otherwise not) so it might respond not assignable at runtime for things that are assignable. I just realized that. We could have an analysis to make it work in optimized code without any code bloat if the feature is not used.\n\nBut we are not using the runtime rebinding code either in optimized code so it is safe to implement it this way but maybe let\u0027s move this to Cast.java so that it is not part of our api yet. What a shame.\n\nThinking more about the problem, some corner cases won\u0027t work. Arrays are not registered in the prototype tables but they could by if only to keep class literals.\n\nJohn, add a todo here and in Class.createForArray/primitive to register all class literals.",
      "parentUuid": "7c58ad41_e8f16849",
      "revId": "12e5bd6fc2ba050ff60fd3a7b92475a64001f50e",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dc76f9c4_f3c5d04b",
        "filename": "user/super/com/google/gwt/emul/java/lang/Class.java",
        "patchSetId": 1
      },
      "lineNbr": 287,
      "author": {
        "id": 5410
      },
      "writtenOn": "2014-03-04T19:27:00Z",
      "side": 1,
      "message": "yes, building Class.isAssignableFrom() was premature and incomplete. my real goal was to be able to handle ConditionWhenTypeAssignable checks at runtime for library compilation.\n\ni\u0027ve removed this and made the Condition implementation more direct and documented to be only safe in the limited conditions available during library compilation.",
      "parentUuid": "7c58ad41_83d40d32",
      "revId": "12e5bd6fc2ba050ff60fd3a7b92475a64001f50e",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    }
  ]
}