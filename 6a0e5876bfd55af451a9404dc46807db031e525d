{
  "comments": [
    {
      "key": {
        "uuid": "8497f201_e7b5f74f",
        "filename": "dev/core/src/com/google/gwt/dev/jjs/impl/GenerateJavaScriptAST.java",
        "patchSetId": 1
      },
      "lineNbr": 2708,
      "author": {
        "id": 5001
      },
      "writtenOn": "2015-09-05T08:28:01Z",
      "side": 1,
      "message": "Did you do a comparison of the output size before/after this change? In an app with several hundreds of @JsType methods (e.g. something like Inbox, but not using closure output format / hybrid compilation), this is going to generate one extra vtable assignment per method. \n\nIn the previous model (if correctly implemented), simple @JsType methods which don\u0027t collide, are simply marked unobfuscatable. \n\nSo the difference you have is, in the old model, you pay more cost at call sides because GWT\u003c-\u003eGWT calls would use the unobfuscated name, but you don\u0027t have O(# jstype method) vtable assignments.\n\nIn the new model, the GWT\u003c-\u003eGWT calls can still use obfuscated identifiers? But each method generates an additional assignment statement per concrete implementor.\n\nFor -XclosureFormattedOutput this doesn\u0027t matter, because Closure can remove the aliases in many cases. But I\u0027d be curious what the effect is on a JsInterop app that uses a ton of JsType methods.\n\nOne way to check it would be to build the Inbox GWT API without closureFormat mode, and with -style OBF.",
      "revId": "6a0e5876bfd55af451a9404dc46807db031e525d",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8497f201_98eed47f",
        "filename": "dev/core/src/com/google/gwt/dev/jjs/impl/GenerateJavaScriptAST.java",
        "patchSetId": 1
      },
      "lineNbr": 2708,
      "author": {
        "id": 5110
      },
      "writtenOn": "2015-09-08T19:24:57Z",
      "side": 1,
      "message": "The new model doesn\u0027t actually uses obfuscated names but it could.\n\nCurrently the assignment are in the form of\n\n  _.\u003cobfs_name\u003e \u003d function() { blah }\n  _.\u003cname\u003e \u003d _.\u003cobfs_name\u003e\n\n for all, instead of directly doing\n\n   _.\u003cname\u003e \u003d function() { blah }\n\nwhere no bridge is needed.\n\nso we basically see 10 extra chars per method (_.\u003cobfs_name\u003e seen twice) which is roughly 10k for one thousand methods at worst scenario (not gzipped). And that shouldn\u0027t effect closure apps.\n\nFurther, like you mentioned this can further optimized to use obfuscate name at call sites and the overall implementation is much simpler. So it seems to me a good trade off.\n\nWe can double check inbox while pulling in the change.",
      "parentUuid": "8497f201_e7b5f74f",
      "revId": "6a0e5876bfd55af451a9404dc46807db031e525d",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    }
  ]
}