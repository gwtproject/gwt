{
  "comments": [
    {
      "key": {
        "uuid": "f583dec2_3cdeb11f",
        "filename": "dev/core/src/com/google/gwt/dev/util/log/AbstractTreeLogger.java",
        "patchSetId": 3
      },
      "lineNbr": 108,
      "author": {
        "id": 5110
      },
      "writtenOn": "2014-10-23T02:05:34Z",
      "side": 1,
      "message": "What is the point of AtomicReference if you are only using set and get methods? Perhaps you just need volatile instead?",
      "revId": "a6f731c08162d6b142c5960a655028fdc38985c6",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "55210a94_1e8f4c88",
        "filename": "dev/core/src/com/google/gwt/dev/util/log/AbstractTreeLogger.java",
        "patchSetId": 3
      },
      "lineNbr": 108,
      "author": {
        "id": 5010
      },
      "writtenOn": "2014-10-23T02:39:39Z",
      "side": 1,
      "message": "As far as I know, there is no difference. I use AtomicReference for this sort of thing just because it\u0027s more obvious that we are thinking about thread safety for this variable.",
      "parentUuid": "f583dec2_3cdeb11f",
      "revId": "a6f731c08162d6b142c5960a655028fdc38985c6",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f583dec2_7df670f4",
        "filename": "dev/core/src/com/google/gwt/dev/util/log/AbstractTreeLogger.java",
        "patchSetId": 3
      },
      "lineNbr": 108,
      "author": {
        "id": 5110
      },
      "writtenOn": "2014-10-23T18:38:07Z",
      "side": 1,
      "message": "While it makes it obvious that there is a thread safety concern, unfortunately it is surprising and time consuming for the developer to go and look around to see it is not really used like an AtomicReference.\nLet\u0027s use just volatile instead.\n\nAlso on the side not, it looks like a good idea to be consistent with similar variables in the class. For example, either use volatile in other similar fields (e.g. loglevel) or keep protecting all fields with a synchronized keyword.",
      "parentUuid": "55210a94_1e8f4c88",
      "revId": "a6f731c08162d6b142c5960a655028fdc38985c6",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7529ae84_d850c2a0",
        "filename": "dev/core/src/com/google/gwt/dev/util/log/AbstractTreeLogger.java",
        "patchSetId": 3
      },
      "lineNbr": 108,
      "author": {
        "id": 5010
      },
      "writtenOn": "2014-10-23T18:41:46Z",
      "side": 1,
      "message": "I don\u0027t know what you mean by \"not really used like an AtomicReference\" since this seems like standard usage to me. How would you expect an AtomicReference to be used?",
      "parentUuid": "f583dec2_7df670f4",
      "revId": "a6f731c08162d6b142c5960a655028fdc38985c6",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f583dec2_5d004c70",
        "filename": "dev/core/src/com/google/gwt/dev/util/log/AbstractTreeLogger.java",
        "patchSetId": 3
      },
      "lineNbr": 108,
      "author": {
        "id": 5110
      },
      "writtenOn": "2014-10-23T18:55:28Z",
      "side": 1,
      "message": "\u003e How would you expect an AtomicReference to be used?\n\nAtomic reference is for \u0027CAS\u0027 operations like compareAndSet, getAndSet and other similar specialized methods benefit from CAS. \n\nRegular \u0027set\u0027 and \u0027get\u0027 are just simple field accessors for a volatile field.",
      "parentUuid": "7529ae84_d850c2a0",
      "revId": "a6f731c08162d6b142c5960a655028fdc38985c6",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7529ae84_2bc76e72",
        "filename": "dev/core/src/com/google/gwt/dev/util/log/AbstractTreeLogger.java",
        "patchSetId": 3
      },
      "lineNbr": 108,
      "author": {
        "id": 5010
      },
      "writtenOn": "2014-10-23T19:34:42Z",
      "side": 1,
      "message": "This doesn\u0027t seem to be generally true in Google code. I did a search on usages of AtomicReference and found many that are only using get() and set(). But I will switch to volatile since it doesn\u0027t affect functionality.",
      "parentUuid": "f583dec2_5d004c70",
      "revId": "a6f731c08162d6b142c5960a655028fdc38985c6",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35a1f65e_5f8b6ffe",
        "filename": "dev/core/src/com/google/gwt/dev/util/log/AbstractTreeLogger.java",
        "patchSetId": 3
      },
      "lineNbr": 108,
      "author": {
        "id": 5110
      },
      "writtenOn": "2014-10-23T21:50:58Z",
      "side": 1,
      "message": "I guess there are other people thinking in similar way.\n\nI\u0027ll leave you and John to decide which one you guys think more readable/helpful but please make sure it is consistent in the class (i.e. choose one (synchronized vs. atomicreference vs. volatile) and use it in all similar fields).",
      "parentUuid": "7529ae84_2bc76e72",
      "revId": "a6f731c08162d6b142c5960a655028fdc38985c6",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f583dec2_7ca2f990",
        "filename": "dev/core/src/com/google/gwt/dev/util/log/MetricMap.java",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 5110
      },
      "writtenOn": "2014-10-23T02:05:34Z",
      "side": 1,
      "message": "Instead of synchronized use ConcurrentHashMap instead? or better  ConcurrentHashMultiset and setCount instead of map.",
      "range": {
        "startLine": 36,
        "startChar": 9,
        "endLine": 36,
        "endChar": 21
      },
      "revId": "a6f731c08162d6b142c5960a655028fdc38985c6",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "55210a94_9e491cb0",
        "filename": "dev/core/src/com/google/gwt/dev/util/log/MetricMap.java",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 5010
      },
      "writtenOn": "2014-10-23T02:39:39Z",
      "side": 1,
      "message": "I switched from ConcurrentHashMap to synchronized methods because it makes the getSnapshot() API a bit simpler to understand. (It\u0027s simpler to guarantee that the snapshot is always consistent than to document that it might not be.)\n\nBut actually, it doesn\u0027t matter much. Most of the time only one thread will be accessing this object at a time, and then synchronization is almost a no-op. I\u0027m only making it thread-safe because we do run the compiler on multiple threads sometimes.",
      "parentUuid": "f583dec2_7ca2f990",
      "range": {
        "startLine": 36,
        "startChar": 9,
        "endLine": 36,
        "endChar": 21
      },
      "revId": "a6f731c08162d6b142c5960a655028fdc38985c6",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f583dec2_bd34f8d4",
        "filename": "dev/core/src/com/google/gwt/dev/util/log/MetricMap.java",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 5110
      },
      "writtenOn": "2014-10-23T18:38:07Z",
      "side": 1,
      "message": "Ack.",
      "parentUuid": "55210a94_9e491cb0",
      "range": {
        "startLine": 36,
        "startChar": 9,
        "endLine": 36,
        "endChar": 21
      },
      "revId": "a6f731c08162d6b142c5960a655028fdc38985c6",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    }
  ]
}