{
  "comments": [
    {
      "key": {
        "uuid": "ad307b13_222f4ee7",
        "filename": "user/super/com/google/gwt/emul/java/util/stream/Collectors.java",
        "patchSetId": 15
      },
      "lineNbr": 95,
      "author": {
        "id": 7220
      },
      "writtenOn": "2016-05-03T21:33:16Z",
      "side": 1,
      "message": "This should be (Supplier\u003cMap\u003cK, List\u003cT\u003e\u003e\u003e) mapFactory instead of HashMap::new. Otherwise we\u0027re accumulating and iterating over the entries (in finisher) using a plain HashMap with unpredictable iteration order. testGroupingBy actually fails for me without this.",
      "revId": "a734ed47e790e0065d4bd6178df5448347446d38",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd484fa3_be3a55ba",
        "filename": "user/super/com/google/gwt/emul/java/util/stream/Collectors.java",
        "patchSetId": 15
      },
      "lineNbr": 95,
      "author": {
        "id": 5130
      },
      "writtenOn": "2016-05-03T22:04:07Z",
      "side": 1,
      "message": "Without reverting to the initial patch (#5, where Thomas requested that I take this easier-to-read approach instead), that doesn\u0027t make sense. Would you agree to LinkedHashMap::new instead here? Or should I back out this \"improved\" version, and see if you/Andrei and Thomas can find middle ground?\n\nTo reiterate, the initial implementation did not use an intermediate map, but instead used the downstream Collector for every operation - creating a new D wrapper for each item, accumulating into it rather than appending to the List\u003cT\u003e, etc. If we can agree that I\u0027m not going to re-revert, I\u0027ll go ahead and revert to that implementation.",
      "parentUuid": "ad307b13_222f4ee7",
      "revId": "a734ed47e790e0065d4bd6178df5448347446d38",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ad307b13_427892e7",
        "filename": "user/super/com/google/gwt/emul/java/util/stream/Collectors.java",
        "patchSetId": 15
      },
      "lineNbr": 95,
      "author": {
        "id": 7220
      },
      "writtenOn": "2016-05-03T22:16:33Z",
      "side": 1,
      "message": "I am likely missing something but don\u0027t see a problem with using the mapFactory here, that\u0027s what open jdk does, but I\u0027d be ok with using LinkedHashMap:new, as it also solves the problem.",
      "parentUuid": "cd484fa3_be3a55ba",
      "revId": "a734ed47e790e0065d4bd6178df5448347446d38",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd484fa3_9ef4b9e1",
        "filename": "user/super/com/google/gwt/emul/java/util/stream/Collectors.java",
        "patchSetId": 15
      },
      "lineNbr": 95,
      "author": {
        "id": 5130
      },
      "writtenOn": "2016-05-03T22:19:15Z",
      "side": 1,
      "message": "The mapFactory produces an `M extends Map\u003cK, D\u003e` (and K, D are unbounded), while this map is `Map\u003cK, List\u003cT\u003e` - they aren\u0027t compatible. I\u0027m accumulating results in the List, and then in the finalizer doing the streamAndCollect to walk the items into the downstream collector so that they live in a D and can be put in the M instance, which is created via the mapFactory as you say.\n\nTake a look at the #5 impl, it may be closer to what you were expecting to see here.",
      "parentUuid": "ad307b13_427892e7",
      "revId": "a734ed47e790e0065d4bd6178df5448347446d38",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    }
  ]
}