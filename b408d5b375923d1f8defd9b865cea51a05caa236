{
  "comments": [
    {
      "key": {
        "uuid": "9555663b_806e17c2",
        "filename": "dev/core/src/com/google/gwt/dev/js/JsUnusedFunctionRemover.java",
        "patchSetId": 4
      },
      "lineNbr": 52,
      "author": {
        "id": 5001
      },
      "writtenOn": "2015-10-01T22:00:17Z",
      "side": 1,
      "message": "This seems kind of ugly. We go from a general purpose mechanism for pinning to a specific lookup for a magically named function. \n\nThis logic exists only so that the FragmentExtractor onLoaded expression can delegate to it. But if there\u0027s any code-splitting live at all, this function must exist, so why don\u0027t we somehow leverage @JsInterop.  Essentially, we\u0027d exporting an entrypoint for the code-splitter fragments to call into.\n\nIf code splitting is turned on, why not programmatically lookup the onLoad() method and mark it exported. It would be unrenameable, which is a shame, but we can make it small.",
      "revId": "b408d5b375923d1f8defd9b865cea51a05caa236",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9555663b_1619ad85",
        "filename": "dev/core/src/com/google/gwt/dev/js/JsUnusedFunctionRemover.java",
        "patchSetId": 4
      },
      "lineNbr": 52,
      "author": {
        "id": 5105
      },
      "writtenOn": "2015-10-02T18:17:06Z",
      "side": 1,
      "message": "Well we had this \"general\" purpose mechanism that was only used for this particular case.\n\nAsyncFragmentLoader is responsible for 2 similar hacks  that get masqueraded opaquely into general purpose. This is one of them and the other is JMethodCall.isVolatile().\n\nHaving these general purpose mechanisms so that they can be used for one specific case seem very wasteful and hides the opportunity to notice the hacky cases and perform the better fix. I prefer that hacks are not hidden.\n\nOther option here is to generate \n\n  AsyncFragmentLoader.onLoad(0) \n\nat the end of the program (if code splitting is active).\n\nFor the isVolatile() issue we should probably introduce an annotation @DoNotOptimizeCalls or maybe @Api and mark the method accordingly.",
      "parentUuid": "9555663b_806e17c2",
      "revId": "b408d5b375923d1f8defd9b865cea51a05caa236",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9555663b_197d5e76",
        "filename": "dev/core/src/com/google/gwt/dev/js/JsUnusedFunctionRemover.java",
        "patchSetId": 4
      },
      "lineNbr": 52,
      "author": {
        "id": 5001
      },
      "writtenOn": "2015-10-02T21:09:16Z",
      "side": 1,
      "message": "To be fair, those were actually used by more than one thing originally. ArtificialRescue was introduced for deRPC, because we didn\u0027t have @JsExport to pin. And volatile existed for the same reason it\u0027s used in C, because we didn\u0027t have anything like @DoNotInline.\n\nThe async special casing is spread into many places, GenJsAst, UnifyAst, CFA, FragmentExtractor. I guess it\u0027s unavoidable, because of the special semantic nature of Async, but I think it\u0027s nice if there\u0027s only one way to mark a method as unprunable. \n\nThat said, I am not overly hung up on it.",
      "parentUuid": "9555663b_1619ad85",
      "revId": "b408d5b375923d1f8defd9b865cea51a05caa236",
      "serverId": "84fdd5b9-d3fc-3149-9ae9-e619898c4c46",
      "unresolved": false
    }
  ]
}